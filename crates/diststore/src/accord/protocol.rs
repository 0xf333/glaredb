use super::keys::{Key, KeySet};
use super::replica::ReplicaState;
use super::timestamp::Timestamp;
use super::transaction::{Transaction, TransactionId, TransactionKind};
use super::{AccordError, NodeId, Result};
use log::debug;
use std::fmt;
use tokio::sync::mpsc;

/// Where to send messages.
#[derive(Debug, Clone, PartialEq)]
pub enum Address {
    /// Broadcast to specific peer.
    Peer(NodeId),
    /// Broadcast to all peers.
    Peers,
    /// Broadcast only to this node.
    Local,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Message<K> {
    from: NodeId,
    to: Address,
    proto_msg: ProtocolMessage<K>,
}

/// Core protocol messages.
#[derive(Debug, Clone, PartialEq)]
pub enum ProtocolMessage<K> {
    /// Begin a read transaction.
    BeginRead {
        keys: KeySet<K>,
        command: Vec<u8>,
    },
    /// Begin a write transaction.
    BeginWrite {
        keys: KeySet<K>,
        command: Vec<u8>,
    },

    PreAccept {
        tx: Transaction<K>,
    },

    PreAcceptOk {
        /// Id of the transaction that this message is concerning.
        tx_id: TransactionId,
        /// Proposed timestamp for the transaction. May be the same as the
        /// original timestamp.
        proposed: Timestamp,
        /// Transaction dependencies.
        deps: Vec<TransactionId>,
    },
}

#[derive(Debug)]
pub struct StateMachine<K> {
    /// Messages generated by this state machine that need to be sent out to
    /// other nodes.
    outbound: mpsc::Sender<Message<K>>,
    /// Node local state.
    replica: ReplicaState<K>,
}

impl<K: Key> StateMachine<K> {
    pub async fn handle_msg(&mut self, from: NodeId, msg: Message<K>) -> Result<()> {
        use ProtocolMessage::*;

        match msg.proto_msg {
            msg @ BeginRead { .. } | msg @ BeginWrite { .. } => {
                let (kind, keys, command) = match msg {
                    BeginRead { keys, command } => (TransactionKind::Read, keys, command),
                    BeginWrite { keys, command } => (TransactionKind::Write, keys, command),
                    _ => unreachable!(),
                };
                let tx = self.replica.new_inflight_tx(kind, keys, command);
                let msg = ProtocolMessage::PreAccept { tx };
                self.send_outbound(Address::Peers, msg).await?;
            }

            PreAccept { tx } => {
                let id = tx.get_id().clone();
                let prop = self.replica.preaccept_tx(tx);
                let (proposed, deps) = match prop {
                    Some(prop) => (prop.proposed_timestamp, prop.deps),
                    None => (id.0.clone(), Vec::new()),
                };
                let msg = ProtocolMessage::PreAcceptOk {
                    tx_id: id,
                    proposed,
                    deps,
                };
                self.send_outbound(Address::Peer(from), msg).await?;
            }

            _ => todo!(),
        };

        Ok(())
    }

    async fn send_outbound(&self, to: Address, msg: ProtocolMessage<K>) -> Result<()> {
        let msg = Message {
            from: self.replica.get_node_id(),
            to,
            proto_msg: msg,
        };
        match self.outbound.send(msg).await {
            Ok(_) => Ok(()),
            Err(msg) => Err(AccordError::OutboundSend(format!("msg: {:?}", msg))),
        }
    }
}
