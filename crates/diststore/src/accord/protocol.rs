use super::coordinator::{AcceptOrCommit, CoordinatorState};
use super::keys::{Key, KeySet};
use super::replica::ReplicaState;
use super::timestamp::Timestamp;
use super::transaction::{Transaction, TransactionId, TransactionKind};
use super::{AccordError, ComputeData, Executor, NodeId, ReadData, Result};
use log::debug;
use std::fmt;
use tokio::sync::mpsc;

/// Where to send messages.
#[derive(Debug, Clone, PartialEq)]
pub enum Address {
    /// Broadcast to specific peer.
    Peer(NodeId),
    /// Broadcast to all peers.
    Peers,
    /// Broadcast only to this node.
    Local,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Message<K> {
    from: NodeId,
    to: Address,
    proto_msg: ProtocolMessage<K>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct PreAccept<K> {
    pub tx: Transaction<K>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct PreAcceptOk {
    /// Id of the transaction that this message is concerning.
    pub tx: TransactionId,
    /// Proposed timestamp for the transaction. May be the same as the
    /// original timestamp.
    pub proposed: Timestamp,
    /// Transaction dependencies as witnessed by the node.
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Accept<K> {
    pub tx: Transaction<K>,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct AcceptOk {
    pub tx: TransactionId,
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Commit<K> {
    pub tx: Transaction<K>,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
}

/// Internal message for the coordinator to begin the execution protocol for a
/// transaction.
#[derive(Debug, Clone, PartialEq)]
pub struct StartExecuteInternal {
    pub tx: TransactionId,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Read<K> {
    pub tx: Transaction<K>,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ReadOk {
    pub tx: TransactionId,
    pub data: ReadData,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Apply<K> {
    pub tx: Transaction<K>,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
    pub data: ComputeData,
}

/// Core protocol messages.
#[derive(Debug, Clone, PartialEq)]
pub enum ProtocolMessage<K> {
    /// Begin a read transaction.
    BeginRead {
        keys: KeySet<K>,
        command: Vec<u8>,
    },
    /// Begin a write transaction.
    BeginWrite {
        keys: KeySet<K>,
        command: Vec<u8>,
    },

    /// Start the execution protocol on the coordinator side. Should be sent
    /// locally immediately after any commit messages are sent.
    StartExecute(StartExecuteInternal),

    PreAccept(PreAccept<K>),
    PreAcceptOk(PreAcceptOk),
    Accept(Accept<K>),
    AcceptOk(AcceptOk),
    Commit(Commit<K>),
    Read(Read<K>),
    ReadOk(ReadOk),
    Apply(Apply<K>),
}

#[derive(Debug)]
pub struct StateMachine<K, E> {
    /// Messages generated by this state machine that need to be sent out to
    /// other nodes.
    outbound: mpsc::Sender<Message<K>>,
    replica: ReplicaState<K, E>,
    coordinator: CoordinatorState<K, E>,
}

impl<K: Key, E: Executor<K>> StateMachine<K, E> {
    pub async fn handle_msg(&mut self, from: NodeId, msg: Message<K>) -> Result<()> {
        use ProtocolMessage::*;

        match msg.proto_msg {
            BeginRead { keys, command } => {
                let msg = self.coordinator.new_read_tx(keys, command);
                self.send_outbound(Address::Peers, ProtocolMessage::PreAccept(msg))
                    .await?;
            }
            BeginWrite { keys, command } => {
                let msg = self.coordinator.new_write_tx(keys, command);
                self.send_outbound(Address::Peers, ProtocolMessage::PreAccept(msg))
                    .await?;
            }
            StartExecute(msg) => {
                let msg = self.coordinator.start_execute(msg)?;
                self.send_outbound(Address::Peers, ProtocolMessage::Read(msg))
                    .await?;
            }
            PreAccept(msg) => {
                let msg = self.replica.receive_preaccept(msg);
                self.send_outbound(Address::Peer(from), ProtocolMessage::PreAcceptOk(msg))
                    .await?;
            }
            PreAcceptOk(msg) => {
                let msg = self.coordinator.store_proposal(from, msg)?;
                match msg {
                    Some(AcceptOrCommit::Accept(msg)) => {
                        self.send_outbound(Address::Peers, ProtocolMessage::Accept(msg))
                            .await?
                    }
                    Some(AcceptOrCommit::Commit(msg)) => {
                        let id = msg.tx.get_id().clone();
                        self.send_outbound(Address::Peers, ProtocolMessage::Commit(msg))
                            .await?;
                        self.send_outbound(
                            Address::Local,
                            ProtocolMessage::StartExecute(StartExecuteInternal { tx: id }),
                        )
                        .await?;
                    }
                    _ => (), // Nothing to send yet.
                }
            }
            Accept(msg) => {
                let msg = self.replica.receive_accept(msg);
                self.send_outbound(Address::Peer(from), ProtocolMessage::AcceptOk(msg))
                    .await?;
            }
            AcceptOk(msg) => {
                let msg = self.coordinator.store_accept_ok(from, msg)?;
                if let Some(msg) = msg {
                    let id = msg.tx.get_id().clone();
                    self.send_outbound(Address::Peers, ProtocolMessage::Commit(msg))
                        .await?;
                    self.send_outbound(
                        Address::Local,
                        ProtocolMessage::StartExecute(StartExecuteInternal { tx: id }),
                    )
                    .await?;
                }
            }
            Commit(msg) => {
                self.replica.receive_commit(msg);
            }
            Read(msg) => {
                let msg = self.replica.receive_read(msg)?;
                self.send_outbound(Address::Peer(from), ProtocolMessage::ReadOk(msg))
                    .await?;
            }
            ReadOk(msg) => {
                let msg = self.coordinator.store_read_ok(msg)?;
                if let Some(msg) = msg {
                    self.send_outbound(Address::Peers, ProtocolMessage::Apply(msg))
                        .await?;
                }
            }
            Apply(msg) => self.replica.receive_apply(msg)?,
        };

        Ok(())
    }

    async fn send_outbound(&self, to: Address, msg: ProtocolMessage<K>) -> Result<()> {
        let msg = Message {
            from: self.replica.get_node_id(),
            to,
            proto_msg: msg,
        };
        match self.outbound.send(msg).await {
            Ok(_) => Ok(()),
            Err(msg) => Err(AccordError::OutboundSend(format!("msg: {:?}", msg))),
        }
    }
}
