use super::keys::{Key, KeySet};
use super::replica::{CommitOrAccept, Proposal, ReplicaState};
use super::timestamp::Timestamp;
use super::transaction::{Transaction, TransactionId, TransactionKind};
use super::{AccordError, ComputeData, NodeId, ReadData, Result};
use log::debug;
use std::fmt;
use tokio::sync::mpsc;

/// Where to send messages.
#[derive(Debug, Clone, PartialEq)]
pub enum Address {
    /// Broadcast to specific peer.
    Peer(NodeId),
    /// Broadcast to all peers.
    Peers,
    /// Broadcast only to this node.
    Local,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Message<K> {
    from: NodeId,
    to: Address,
    proto_msg: ProtocolMessage<K>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct PreAccept<K> {
    pub tx: Transaction<K>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct PreAcceptOk {
    /// Id of the transaction that this message is concerning.
    pub tx: TransactionId,
    /// Proposed timestamp for the transaction. May be the same as the
    /// original timestamp.
    pub proposed: Timestamp,
    /// Transaction dependencies as witnessed by the node.
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Accept {
    pub tx: TransactionId,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct AcceptOk {
    pub tx: TransactionId,
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Commit {
    pub tx: TransactionId,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
}

/// Internal message for the coordinator to begin the execution protocol for a
/// transaction.
#[derive(Debug, Clone, PartialEq)]
pub struct StartExecute {
    pub tx: TransactionId,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Read {
    pub tx: TransactionId,
    pub timestamp: Timestamp,
    pub deps: Vec<TransactionId>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ReadOk {
    pub tx: TransactionId,
    pub data: ReadData,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Apply {
    pub tx: TransactionId,
    pub data: ComputeData,
}

/// Core protocol messages.
#[derive(Debug, Clone, PartialEq)]
pub enum ProtocolMessage<K> {
    /// Begin a read transaction.
    BeginRead {
        keys: KeySet<K>,
        command: Vec<u8>,
    },
    /// Begin a write transaction.
    BeginWrite {
        keys: KeySet<K>,
        command: Vec<u8>,
    },

    PreAccept {
        tx: Transaction<K>,
    },

    PreAcceptOk {
        /// Id of the transaction that this message is concerning.
        tx_id: TransactionId,
        /// Proposed timestamp for the transaction. May be the same as the
        /// original timestamp.
        proposed: Timestamp,
        /// Transaction dependencies.
        deps: Vec<TransactionId>,
    },

    Accept {
        tx_id: TransactionId,
        timestamp: Timestamp,
        deps: Vec<TransactionId>,
    },

    AcceptOk {
        tx_id: TransactionId,
        deps: Vec<TransactionId>,
    },

    Commit {
        tx_id: TransactionId,
        timestamp: Timestamp,
        deps: Vec<TransactionId>,
    },
}

#[derive(Debug)]
pub struct StateMachine<K> {
    /// Messages generated by this state machine that need to be sent out to
    /// other nodes.
    outbound: mpsc::Sender<Message<K>>,
    /// Node local state.
    replica: ReplicaState<K>,
}

impl<K: Key> StateMachine<K> {
    pub async fn handle_msg(&mut self, from: NodeId, msg: Message<K>) -> Result<()> {
        use ProtocolMessage::*;

        match msg.proto_msg {
            msg @ BeginRead { .. } | msg @ BeginWrite { .. } => {
                let (kind, keys, command) = match msg {
                    BeginRead { keys, command } => (TransactionKind::Read, keys, command),
                    BeginWrite { keys, command } => (TransactionKind::Write, keys, command),
                    _ => unreachable!(),
                };
                let tx = self.replica.new_inflight_tx(kind, keys, command);
                let msg = ProtocolMessage::PreAccept { tx };
                self.send_outbound(Address::Peers, msg).await?;
            }

            PreAccept { tx } => {
                let id = tx.get_id().clone();
                let prop = self.replica.preaccept_tx(tx);
                let (proposed, deps) = match prop {
                    Some(prop) => (prop.proposed_timestamp, prop.deps),
                    None => (id.0.clone(), Vec::new()),
                };
                let msg = ProtocolMessage::PreAcceptOk {
                    tx_id: id,
                    proposed,
                    deps,
                };
                self.send_outbound(Address::Peer(from), msg).await?;
            }

            PreAcceptOk {
                tx_id,
                proposed,
                deps,
            } => {
                let prop = Proposal {
                    deps,
                    proposed_timestamp: proposed,
                };
                match self.replica.coord_preaccept_proposal(from, &tx_id, prop)? {
                    Some(CommitOrAccept::Commit { timestamp, deps }) => {
                        self.send_outbound(
                            Address::Peers,
                            ProtocolMessage::Commit {
                                tx_id,
                                timestamp,
                                deps,
                            },
                        )
                        .await?
                    }
                    Some(CommitOrAccept::Accept { timestamp, deps }) => {
                        self.send_outbound(
                            Address::Peers,
                            ProtocolMessage::Accept {
                                tx_id,
                                timestamp,
                                deps,
                            },
                        )
                        .await?
                    }
                    None => (), // Nothing to send, waiting for more responses.
                }
            }

            Accept {
                tx_id,
                timestamp,
                deps,
            } => {
                let deps = self.replica.accept(&tx_id, timestamp, deps)?;
                self.send_outbound(
                    Address::Peer(from),
                    ProtocolMessage::AcceptOk { tx_id, deps },
                )
                .await?;
            }

            _ => todo!(),
        };

        Ok(())
    }

    async fn send_outbound(&self, to: Address, msg: ProtocolMessage<K>) -> Result<()> {
        let msg = Message {
            from: self.replica.get_node_id(),
            to,
            proto_msg: msg,
        };
        match self.outbound.send(msg).await {
            Ok(_) => Ok(()),
            Err(msg) => Err(AccordError::OutboundSend(format!("msg: {:?}", msg))),
        }
    }
}
