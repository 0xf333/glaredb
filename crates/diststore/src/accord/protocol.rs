use super::keys::{Key, KeySet};
use super::replica::ReplicaState;
use super::timestamp::Timestamp;
use super::transaction::{Transaction, TransactionId, TransactionKind};
use super::{AccordError, NodeId, Result};
use log::debug;
use std::fmt;
use tokio::sync::mpsc;

/// Where to send messages.
#[derive(Debug, Clone, PartialEq)]
pub enum Address {
    /// Broadcast to all peers.
    Peers,
    /// Broadcast only to this node.
    Local,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Message<K> {
    address: Address,
    proto_msg: ProtocolMessage<K>,
}

/// Core protocol messages.
#[derive(Debug, Clone, PartialEq)]
pub enum ProtocolMessage<K> {
    /// Begin a read transaction.
    BeginRead { keys: KeySet<K>, command: Vec<u8> },
    /// Begin a write transaction.
    BeginWrite { keys: KeySet<K>, command: Vec<u8> },

    /// Accord's "PreAccept" message.
    PreAccept {
        /// Original proposed timestamp for the transaction.
        t0: Timestamp,
        tx: Transaction<K>,
    },
}

#[derive(Debug)]
pub struct StateMachine<K> {
    /// Messages generated by this state machine that need to be sent out to
    /// other nodes.
    outbound: mpsc::Sender<Message<K>>,
    /// Node local state.
    replica: ReplicaState<K>,
}

impl<K: Key> StateMachine<K> {
    pub async fn handle_msg(&mut self, msg: Message<K>) -> Result<()> {
        use ProtocolMessage::*;

        match msg.proto_msg {
            msg @ BeginRead { .. } | msg @ BeginWrite { .. } => {
                let (kind, keys, command) = match msg {
                    BeginRead { keys, command } => (TransactionKind::Read, keys, command),
                    BeginWrite { keys, command } => (TransactionKind::Write, keys, command),
                    _ => unreachable!(),
                };
                let tx = self.replica.new_inflight_tx(kind, keys, command);
                self.send_outbound(Message {
                    address: Address::Peers,
                    proto_msg: ProtocolMessage::PreAccept {
                        t0: tx.get_id().0.clone(),
                        tx,
                    },
                })
                .await?;
            }
            _ => todo!(),
        };

        Ok(())
    }

    async fn send_outbound(&self, msg: Message<K>) -> Result<()> {
        match self.outbound.send(msg).await {
            Ok(_) => Ok(()),
            Err(msg) => Err(AccordError::OutboundSend(format!("msg: {:?}", msg))),
        }
    }
}
